一   事务
    事务一般指的是逻辑上一组操作，要么全部执行成功，要么全部执行失败。事务概念可以从事务的特性进行理解，本章节介绍事务的4种特性并结合转账业务进行介绍。
    1.1 原子性
        构成事务的所有操作作为一个整体，要么全部执行成功，要么全部执行失败；不存在部分执行成功，部分失败的场景。
        如A给B转账100元行为只可能存在两种结果：执行成功,A账户扣除100元且B账户增加100元；执行失败，A和B账户金额保持不变。
    1.2 一致性
        事务执行前后，从业务侧的角度，系统处于数据一致性状态。A向B转账无论是否成功，银行系统需要保证A和B账户的总额保持不变。
    1.3 隔离性
        并发执行的事务之间相互不可见、互不干扰。A向B转账(事务1)的同时，B向A或者B向C转账(事务2)，若事务1没有提交，事务2无法感知。
    1.4 持久性
        事务被提交后会被持久化，不可回滚，从而可以被其他事务感知。A向B转账完成后，表面该事务已执行完成并持久化入数据库，不可回滚，B账户查询余额可以看到转账的结果

二   MySql数据库事务
    数据库一般会并发执行多个事务，而事务的并发执行会带来并发事务问题，如：脏读、不可重复读、幻读等；数据库因此引入了隔离级别的概念。
    2.1 隔离级别
        数据库的隔离级别按照限制顺序依次包括读未提交、读已提交、可重复读、串行化；隔离级别越高，处理事务并发问题的能力越强，但效率越低。
        2.1.1   读未提交
            能读取其他事务尚未提交的操作，其他事务回滚时，会导致脏读。
        2.1.2   读已提交
            只能读取其他事务已提交的操作，不存在脏读；但事务中同一条件多次查询的结果可能不一致，导致不可重复读。读已提交是Oracle和Sql Server的默认隔离级别。
        2.1.3   可重复读
            在事务中同一条件多次查询的结果一致；但有新纪录插入数据库时，查不到新纪录，但新增、更新、删除等操作影响新记录或受新记录影像，导致幻读。可重复读是Mysql的默认隔离级别。
        2.1.4   串行化
            串行化作为最高的隔离级别，可以解决幻读的问题；但是所有操作都是串行执行、效率较低，一般业务场景不适用。

三   Spring事务传播机制
    3.1 传播机制
        Spring提供了7种事务传播机制以应对不同的业务场景；本章节结合案例分别进行介绍，案例均基于下图模型：
        参考图片:./pic/transaction/01_transaction.png
        方法A和方法B位于不同的类中，且均为public且非static方法，在A方法中依次调用B1、B2、B3方法。
        3.1.1   Required
            原则是：有就加入；没有就自创一个
            3.1.1.1 A没有事务时
                B1/B2/B3自行开启事务，此时3个事务相互独立，互补影响；
            3.1.1.2 A存在事务时
                B1/B2/B3加入到事物A中，相互影响；即全部执行成功 或 任何一个方法执行失败—全部回滚；
                另外，Required是Spring的默认隔离级别，如在@Transaction注解中不指定隔离级别时—使用Required。
        3.1.2   Required_New
            原则是：没有新建一个；有，也新建一个相互隔离的事务
            3.1.2.1 A没有事务
                B1/B2/B3自行开启事务，此时3个事务相互独立，互不影响；
            3.1.2.2 A存在事务时：
                B1/B2/B3自行开启事务，共计4个互不影响的事务；任何一个事务失败仅仅回滚自己的事务，不影响其他事务。
                即存在事务A和B1/B2执行成功，B3执行失败场景。
        3.1.3   Support
            原则是：有就加入，没有也行
            3.1.3.1 A没有事务时
                B1/B2/B3以非事务方式运行；
            3.1.3.2 A存在事务时：
                B1/B2/B3加入到事务A中，相互影响；即全部执行成功 或 任何一个方法执行失败—全部回滚；
        3.1.4   Not_Support
             原则是：无论是否有事务，自己以非事务执行
             3.1.4.1    A没有事务时
                B1/B2/B3以非事务方式运行；
             3.1.4.2    A存在事务时：
                B1/B2/B3以非事务方式运行；
        3.1.5   Mandatory
            原则是：必须要有事务，没有抛出异常，有事务-就加入
            3.1.5.1 A没有事务时：
                执行B方法时，抛出异常；
            3.1.5.2 A存在事务时：
                B1/B2/B3加入到事务A中，相互影响；即全部执行成功 或 任何一个方法执行失败—全部回滚；
        3.1.6   never
            原则是：不支持事务，有事务就抛出异常
            3.1.6.1 A没有事务时：
                B1/B2/B3以非事务方式运行；
            3.1.6.2 A存在事务时：
                执行B方法时，抛出异常；
        3.1.7   nested
            原则是：没有-新建一个事务；有-新建一个子事务(子不影响父，父影响子)
            3.1.7.1 A没有事务时
                B1/B2/B3自行开启事务，此时3个事务相互独立，互补影响；
            3.1.7.2 A存在事务时：
                B1/B2/B3自行开启子事务，此时3个事务通过事务A相互关联；
                基于嵌套子事务不影响父事务的性质：B1/B2/B3事务执行失败时，只会导致自己对应事务回滚，不影响事务A的正常执行；
                基于父事务影响嵌套子事务的性质：A执行失败时，会回滚事务A和所有的事务B.
    3.2 案例介绍
        以下为基础用例，本章节所有案例均在该基础用例上定制修改，所有案例测试完成后，均回滚数据库至基础用例状态

























文章来源:
https://blog.csdn.net/Sheng_Q/article/details/126440133
