1、spring-boot启动的时候加载配置文件流程
    org.springframework.boot.SpringApplication#prepareEnvironment()
    --->org.springframework.boot.env.EnvironmentPostProcessorApplicationListener#onApplicationEnvironmentPreparedEvent()
        --->org.springframework.boot.context.config.ConfigDataEnvironmentPostProcessor#postProcessEnvironment()
            --->org.springframework.boot.context.config.ConfigDataEnvironment#processAndApply()
                --->org.springframework.boot.context.config.ConfigDataEnvironment#processInitial()
                    --->org.springframework.boot.context.config.ConfigDataEnvironmentContributors#withProcessedImports()
                        --->org.springframework.boot.context.config.ConfigDataEnvironmentContributors#withProcessedImports()
                            --->org.springframework.boot.context.config.ConfigDataImporter#resolveAndLoad()
                                --->org.springframework.boot.context.config.ConfigDataImporter#resolveAndLoad()
                                    -->org.springframework.boot.context.config.ConfigDataImporter#load()
                                        --->org.springframework.boot.context.config.ConfigDataLoaders#load()
                                            --->org.springframework.boot.context.config.StandardConfigDataLoader#load()
                                                --->org.springframework.boot.env.YamlPropertySourceLoader#load()
    EnvironmentPostProcessorApplicationListener能够监听是因为在spring.factories文件中配置了该监听器


2、自定义applicaton.txt
    我们观察application.properties和application.yml文件的处理类分别为PropertiesPropertySourceLoader和YamlPropertySourceLoader,所以我们也可以仿照PropertiesPropertySourceLoader写一个自己的实现类TxtPropertySourceLoader,并在classpath:路径下添加application.txt和META-INF/spring.factories文件，其中META-INF/spring.factories文件添加如下：
    # PropertySource Loaders
    org.springframework.boot.env.PropertySourceLoader=\
    com.rookie.bigdata.boot.env.TxtPropertySourceLoader
    我们在TxtPropertySourceLoaderTest进行测试，发现 成功了，这就是我们自定义applicaton.txt的原理

3、spring.profiles.active=dev的理解
    当设置spring.profiles.active=dev的时候，会将该属性设置到Profiles对象上面，后面加载配置文件的时候，会通过该方法org.springframework.boot.context.config.ConfigDataEnvironment#processAndApply()进行加载，对于spring.profiles.active=dev的理解，如下
	void processAndApply() {
		ConfigDataImporter importer = new ConfigDataImporter(this.logFactory, this.notFoundAction, this.resolvers,
				this.loaders);
		registerBootstrapBinder(this.contributors, null, DENY_INACTIVE_BINDING);
		ConfigDataEnvironmentContributors contributors = processInitial(this.contributors, importer);
		ConfigDataActivationContext activationContext = createActivationContext(
				contributors.getBinder(null, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE));
				//加载不包含dev的配置文件，如 application.properties
		contributors = processWithoutProfiles(contributors, importer, activationContext);
		//解析Profiles
		activationContext = withProfiles(contributors, activationContext);
		//加载包含dev的配置文件，如 application-dev.properties
		contributors = processWithProfiles(contributors, importer, activationContext);
		applyToEnvironment(contributors, activationContext, importer.getLoadedLocations(),
				importer.getOptionalLocations());
	}

    application-dev.properties的加载过程主要如下：
        org.springframework.boot.context.config.ConfigDataEnvironmentContributors#withProcessedImports()
            --->org.springframework.boot.context.config.ConfigDataImporter#resolveAndLoad()
                --->org.springframework.boot.context.config.ConfigDataLocationResolvers#resolve()
                    --->org.springframework.boot.context.config.StandardConfigDataLocationResolver#resolveProfileSpecific()



4、spring.config.name的理解
    spring.config.name配置信息可用参考StandardConfigDataLocationResolver类，里面有一个getConfigNames()方法，也就是获取spring.config.name的配置，如果为空则默认使用application，这个就是项目启动时要加载的配置文件,所以我们可用根据这个配置项来更改项目启动时加载的配置文件信息。如:在启动jar包的时候 用如下命令：java -jar myproject.jar --spring.config.name=myproject, 我们为了测试方便，直接在idea中进行设置，参考pic/1724203030399.png

5、spring.config.location与spring.config.additional-location
    spring.config.location与上面的spring.config.name配置方式时一致的,用于指定配置文件替代springboot中的默认配置文件
    --spring.config.location=classpath:/pro/a.yml
    同理spring.config.additional-location与spring.config.name的配置方式一致，spring.config.additional-location用于添加额外的配置，
    --spring.config.additional-location=classpath:/pro/a.yml





具体可用参考：https://docs.spring.io/spring-boot/how-to/properties-and-configuration.html






























